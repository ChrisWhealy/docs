# Building a Client

When it comes to building a client the `Cargo.toml` file will have the same dependencies as the kernel as seen below:

```toml
[package]
name = "client"
version = "0.1.0"
edition = "2021"

[dependencies]
nanoservices-utils = "0.1.1"
serde = { version = "1.0.197", features = ["derive"] }
tokio = { version = "1.37.0", features = ["full"] }
bincode = "1.3.3"
kernel = { path = "../kernel" }
tokio-util = { version = "0.7", features = ["codec"] }
bytes = "1.6.0"
futures = "0.3.30"
```

The client is the easiest to build as the sending of the contract over TCP code is already generated by the `create_contract_handler`
macro we used in the kernel. We can then import the contracts and send them over TCP to our server with the following code:

```rust
use kernel::{
    TestContractHandler,
    ContractOne,
};
use nanoservices_utils::errors::NanoServiceError;


#[tokio::main]
async fn main() -> Result<(), NanoServiceError> {
    let contract_one = TestContractHandler::ContractOne(ContractOne {
        input_data: 5,
        result: None,
        error: None,
    });

    let result = contract_one.send_over_tcp("127.0.0.1:8080").await?.ContractOne()?;
    println!("{:?}", result);

    let contract_one = TestContractHandler::ContractOne(ContractOne {
        input_data: -5,
        result: None,
        error: None,
    });
    let result = contract_one.send_over_tcp("127.0.0.1:8080").await?.ContractOne()?;
    println!("{:?}", result);
    Ok(())
}
```
And there we have it, our client and server can talk to each other.